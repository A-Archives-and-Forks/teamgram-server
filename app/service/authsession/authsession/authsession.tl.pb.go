// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authsession.tl.proto

package authsession

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                          TLConstructor = 0
	CRC32_clientSession                    TLConstructor = -1701940816
	CRC32_authKeyStateData                 TLConstructor = -646863312
	CRC32_authsession_getAuthorizations    TLConstructor = 820122180
	CRC32_authsession_resetAuthorization   TLConstructor = -1923126106
	CRC32_authsession_getLayer             TLConstructor = -1473309015
	CRC32_authsession_getLangPack          TLConstructor = 700170598
	CRC32_authsession_getClient            TLConstructor = 1616401854
	CRC32_authsession_getLangCode          TLConstructor = 1486468441
	CRC32_authsession_getUserId            TLConstructor = 1464409260
	CRC32_authsession_getPushSessionId     TLConstructor = -1279119039
	CRC32_authsession_getFutureSalts       TLConstructor = -1194371051
	CRC32_authsession_queryAuthKey         TLConstructor = 1421293608
	CRC32_authsession_setAuthKey           TLConstructor = 1049889937
	CRC32_authsession_bindAuthKeyUser      TLConstructor = 198050851
	CRC32_authsession_unbindAuthKeyUser    TLConstructor = 123258440
	CRC32_authsession_getPermAuthKeyId     TLConstructor = -1871420202
	CRC32_authsession_bindTempAuthKey      TLConstructor = 1620004742
	CRC32_authsession_setClientSessionInfo TLConstructor = 47841172
	CRC32_authsession_getAuthorization     TLConstructor = 1851660579
	CRC32_authsession_getAuthStateData     TLConstructor = 1331573041
	CRC32_authsession_setLayer             TLConstructor = 1147475077
	CRC32_authsession_setInitConnection    TLConstructor = 2095024780
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	-1701940816: "CRC32_clientSession",
	-646863312:  "CRC32_authKeyStateData",
	820122180:   "CRC32_authsession_getAuthorizations",
	-1923126106: "CRC32_authsession_resetAuthorization",
	-1473309015: "CRC32_authsession_getLayer",
	700170598:   "CRC32_authsession_getLangPack",
	1616401854:  "CRC32_authsession_getClient",
	1486468441:  "CRC32_authsession_getLangCode",
	1464409260:  "CRC32_authsession_getUserId",
	-1279119039: "CRC32_authsession_getPushSessionId",
	-1194371051: "CRC32_authsession_getFutureSalts",
	1421293608:  "CRC32_authsession_queryAuthKey",
	1049889937:  "CRC32_authsession_setAuthKey",
	198050851:   "CRC32_authsession_bindAuthKeyUser",
	123258440:   "CRC32_authsession_unbindAuthKeyUser",
	-1871420202: "CRC32_authsession_getPermAuthKeyId",
	1620004742:  "CRC32_authsession_bindTempAuthKey",
	47841172:    "CRC32_authsession_setClientSessionInfo",
	1851660579:  "CRC32_authsession_getAuthorization",
	1331573041:  "CRC32_authsession_getAuthStateData",
	1147475077:  "CRC32_authsession_setLayer",
	2095024780:  "CRC32_authsession_setInitConnection",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                          0,
	"CRC32_clientSession":                    -1701940816,
	"CRC32_authKeyStateData":                 -646863312,
	"CRC32_authsession_getAuthorizations":    820122180,
	"CRC32_authsession_resetAuthorization":   -1923126106,
	"CRC32_authsession_getLayer":             -1473309015,
	"CRC32_authsession_getLangPack":          700170598,
	"CRC32_authsession_getClient":            1616401854,
	"CRC32_authsession_getLangCode":          1486468441,
	"CRC32_authsession_getUserId":            1464409260,
	"CRC32_authsession_getPushSessionId":     -1279119039,
	"CRC32_authsession_getFutureSalts":       -1194371051,
	"CRC32_authsession_queryAuthKey":         1421293608,
	"CRC32_authsession_setAuthKey":           1049889937,
	"CRC32_authsession_bindAuthKeyUser":      198050851,
	"CRC32_authsession_unbindAuthKeyUser":    123258440,
	"CRC32_authsession_getPermAuthKeyId":     -1871420202,
	"CRC32_authsession_bindTempAuthKey":      1620004742,
	"CRC32_authsession_setClientSessionInfo": 47841172,
	"CRC32_authsession_getAuthorization":     1851660579,
	"CRC32_authsession_getAuthStateData":     1331573041,
	"CRC32_authsession_setLayer":             1147475077,
	"CRC32_authsession_setInitConnection":    2095024780,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{0}
}

// AuthKeyStateData <--
//  + TL_authKeyStateData
//
type AuthKeyStateData struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyState             int32         `protobuf:"varint,5,opt,name=key_state,json=keyState,proto3" json:"key_state,omitempty"`
	Layer                int32         `protobuf:"varint,6,opt,name=layer,proto3" json:"layer,omitempty"`
	ClientType           int32         `protobuf:"varint,7,opt,name=client_type,json=clientType,proto3" json:"client_type,omitempty"`
	AndroidPushSessionId int64         `protobuf:"varint,8,opt,name=android_push_session_id,json=androidPushSessionId,proto3" json:"android_push_session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AuthKeyStateData) Reset()         { *m = AuthKeyStateData{} }
func (m *AuthKeyStateData) String() string { return proto.CompactTextString(m) }
func (*AuthKeyStateData) ProtoMessage()    {}
func (*AuthKeyStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{0}
}
func (m *AuthKeyStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeyStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeyStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthKeyStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeyStateData.Merge(m, src)
}
func (m *AuthKeyStateData) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeyStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeyStateData.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeyStateData proto.InternalMessageInfo

func (m *AuthKeyStateData) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *AuthKeyStateData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *AuthKeyStateData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AuthKeyStateData) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AuthKeyStateData) GetKeyState() int32 {
	if m != nil {
		return m.KeyState
	}
	return 0
}

func (m *AuthKeyStateData) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *AuthKeyStateData) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *AuthKeyStateData) GetAndroidPushSessionId() int64 {
	if m != nil {
		return m.AndroidPushSessionId
	}
	return 0
}

type TLAuthKeyStateData struct {
	Data2                *AuthKeyStateData `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLAuthKeyStateData) Reset()         { *m = TLAuthKeyStateData{} }
func (m *TLAuthKeyStateData) String() string { return proto.CompactTextString(m) }
func (*TLAuthKeyStateData) ProtoMessage()    {}
func (*TLAuthKeyStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{1}
}
func (m *TLAuthKeyStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthKeyStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthKeyStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthKeyStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthKeyStateData.Merge(m, src)
}
func (m *TLAuthKeyStateData) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthKeyStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthKeyStateData.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthKeyStateData proto.InternalMessageInfo

func (m *TLAuthKeyStateData) GetData2() *AuthKeyStateData {
	if m != nil {
		return m.Data2
	}
	return nil
}

// ClientSession <--
//  + TL_clientSession
//
type ClientSession struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Ip                   string        `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	Layer                int32         `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
	ApiId                int32         `protobuf:"varint,6,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel          string        `protobuf:"bytes,7,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion        string        `protobuf:"bytes,8,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion           string        `protobuf:"bytes,9,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	SystemLangCode       string        `protobuf:"bytes,10,opt,name=system_lang_code,json=systemLangCode,proto3" json:"system_lang_code,omitempty"`
	LangPack             string        `protobuf:"bytes,11,opt,name=lang_pack,json=langPack,proto3" json:"lang_pack,omitempty"`
	LangCode             string        `protobuf:"bytes,12,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Proxy                string        `protobuf:"bytes,13,opt,name=proxy,proto3" json:"proxy,omitempty"`
	Params               string        `protobuf:"bytes,14,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ClientSession) Reset()         { *m = ClientSession{} }
func (m *ClientSession) String() string { return proto.CompactTextString(m) }
func (*ClientSession) ProtoMessage()    {}
func (*ClientSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{2}
}
func (m *ClientSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSession.Merge(m, src)
}
func (m *ClientSession) XXX_Size() int {
	return m.Size()
}
func (m *ClientSession) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSession.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSession proto.InternalMessageInfo

func (m *ClientSession) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *ClientSession) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *ClientSession) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *ClientSession) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ClientSession) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ClientSession) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *ClientSession) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *ClientSession) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *ClientSession) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *ClientSession) GetSystemLangCode() string {
	if m != nil {
		return m.SystemLangCode
	}
	return ""
}

func (m *ClientSession) GetLangPack() string {
	if m != nil {
		return m.LangPack
	}
	return ""
}

func (m *ClientSession) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *ClientSession) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *ClientSession) GetParams() string {
	if m != nil {
		return m.Params
	}
	return ""
}

type TLClientSession struct {
	Data2                *ClientSession `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLClientSession) Reset()         { *m = TLClientSession{} }
func (m *TLClientSession) String() string { return proto.CompactTextString(m) }
func (*TLClientSession) ProtoMessage()    {}
func (*TLClientSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{3}
}
func (m *TLClientSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLClientSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLClientSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLClientSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLClientSession.Merge(m, src)
}
func (m *TLClientSession) XXX_Size() int {
	return m.Size()
}
func (m *TLClientSession) XXX_DiscardUnknown() {
	xxx_messageInfo_TLClientSession.DiscardUnknown(m)
}

var xxx_messageInfo_TLClientSession proto.InternalMessageInfo

func (m *TLClientSession) GetData2() *ClientSession {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetAuthorizations struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ExcludeAuthKeyId     int64         `protobuf:"varint,4,opt,name=exclude_auth_keyId,json=excludeAuthKeyId,proto3" json:"exclude_auth_keyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthorizations) Reset()         { *m = TLAuthsessionGetAuthorizations{} }
func (m *TLAuthsessionGetAuthorizations) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthorizations) ProtoMessage()    {}
func (*TLAuthsessionGetAuthorizations) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{4}
}
func (m *TLAuthsessionGetAuthorizations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthorizations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthorizations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthorizations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthorizations.Merge(m, src)
}
func (m *TLAuthsessionGetAuthorizations) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthorizations) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthorizations.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthorizations proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthorizations) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthorizations) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionGetAuthorizations) GetExcludeAuthKeyId() int64 {
	if m != nil {
		return m.ExcludeAuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionResetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Hash                 int64         `protobuf:"varint,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionResetAuthorization) Reset()         { *m = TLAuthsessionResetAuthorization{} }
func (m *TLAuthsessionResetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionResetAuthorization) ProtoMessage()    {}
func (*TLAuthsessionResetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{5}
}
func (m *TLAuthsessionResetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionResetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionResetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionResetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionResetAuthorization.Merge(m, src)
}
func (m *TLAuthsessionResetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionResetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionResetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionResetAuthorization proto.InternalMessageInfo

func (m *TLAuthsessionResetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionResetAuthorization) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionResetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionResetAuthorization) GetHash() int64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetLayer struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLayer) Reset()         { *m = TLAuthsessionGetLayer{} }
func (m *TLAuthsessionGetLayer) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLayer) ProtoMessage()    {}
func (*TLAuthsessionGetLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{6}
}
func (m *TLAuthsessionGetLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLayer.Merge(m, src)
}
func (m *TLAuthsessionGetLayer) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLayer proto.InternalMessageInfo

func (m *TLAuthsessionGetLayer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLayer) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetLangPack struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLangPack) Reset()         { *m = TLAuthsessionGetLangPack{} }
func (m *TLAuthsessionGetLangPack) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLangPack) ProtoMessage()    {}
func (*TLAuthsessionGetLangPack) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{7}
}
func (m *TLAuthsessionGetLangPack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLangPack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLangPack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLangPack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLangPack.Merge(m, src)
}
func (m *TLAuthsessionGetLangPack) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLangPack) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLangPack.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLangPack proto.InternalMessageInfo

func (m *TLAuthsessionGetLangPack) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLangPack) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetClient struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetClient) Reset()         { *m = TLAuthsessionGetClient{} }
func (m *TLAuthsessionGetClient) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetClient) ProtoMessage()    {}
func (*TLAuthsessionGetClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{8}
}
func (m *TLAuthsessionGetClient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetClient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetClient.Merge(m, src)
}
func (m *TLAuthsessionGetClient) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetClient) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetClient.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetClient proto.InternalMessageInfo

func (m *TLAuthsessionGetClient) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetClient) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetLangCode struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLangCode) Reset()         { *m = TLAuthsessionGetLangCode{} }
func (m *TLAuthsessionGetLangCode) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLangCode) ProtoMessage()    {}
func (*TLAuthsessionGetLangCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{9}
}
func (m *TLAuthsessionGetLangCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLangCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLangCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLangCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLangCode.Merge(m, src)
}
func (m *TLAuthsessionGetLangCode) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLangCode) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLangCode.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLangCode proto.InternalMessageInfo

func (m *TLAuthsessionGetLangCode) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLangCode) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetUserId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetUserId) Reset()         { *m = TLAuthsessionGetUserId{} }
func (m *TLAuthsessionGetUserId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetUserId) ProtoMessage()    {}
func (*TLAuthsessionGetUserId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{10}
}
func (m *TLAuthsessionGetUserId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetUserId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetUserId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetUserId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetUserId.Merge(m, src)
}
func (m *TLAuthsessionGetUserId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetUserId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetUserId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetUserId proto.InternalMessageInfo

func (m *TLAuthsessionGetUserId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetUserId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetPushSessionId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	TokenType            int32         `protobuf:"varint,5,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetPushSessionId) Reset()         { *m = TLAuthsessionGetPushSessionId{} }
func (m *TLAuthsessionGetPushSessionId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetPushSessionId) ProtoMessage()    {}
func (*TLAuthsessionGetPushSessionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{11}
}
func (m *TLAuthsessionGetPushSessionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetPushSessionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetPushSessionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetPushSessionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetPushSessionId.Merge(m, src)
}
func (m *TLAuthsessionGetPushSessionId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetPushSessionId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetPushSessionId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetPushSessionId proto.InternalMessageInfo

func (m *TLAuthsessionGetPushSessionId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetPushSessionId) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionGetPushSessionId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionGetPushSessionId) GetTokenType() int32 {
	if m != nil {
		return m.TokenType
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetFutureSalts struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Num                  int32         `protobuf:"varint,4,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetFutureSalts) Reset()         { *m = TLAuthsessionGetFutureSalts{} }
func (m *TLAuthsessionGetFutureSalts) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetFutureSalts) ProtoMessage()    {}
func (*TLAuthsessionGetFutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{12}
}
func (m *TLAuthsessionGetFutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetFutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetFutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetFutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetFutureSalts.Merge(m, src)
}
func (m *TLAuthsessionGetFutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetFutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetFutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetFutureSalts proto.InternalMessageInfo

func (m *TLAuthsessionGetFutureSalts) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetFutureSalts) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionGetFutureSalts) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionQueryAuthKey struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionQueryAuthKey) Reset()         { *m = TLAuthsessionQueryAuthKey{} }
func (m *TLAuthsessionQueryAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionQueryAuthKey) ProtoMessage()    {}
func (*TLAuthsessionQueryAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{13}
}
func (m *TLAuthsessionQueryAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionQueryAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionQueryAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionQueryAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionQueryAuthKey.Merge(m, src)
}
func (m *TLAuthsessionQueryAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionQueryAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionQueryAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionQueryAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionQueryAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionQueryAuthKey) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionSetAuthKey struct {
	Constructor          TLConstructor        `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKey              *mtproto.AuthKeyInfo `protobuf:"bytes,3,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	FutureSalt           *mtproto.FutureSalt  `protobuf:"bytes,4,opt,name=future_salt,json=futureSalt,proto3" json:"future_salt,omitempty"`
	ExpiresIn            int32                `protobuf:"varint,5,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TLAuthsessionSetAuthKey) Reset()         { *m = TLAuthsessionSetAuthKey{} }
func (m *TLAuthsessionSetAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetAuthKey) ProtoMessage()    {}
func (*TLAuthsessionSetAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{14}
}
func (m *TLAuthsessionSetAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetAuthKey.Merge(m, src)
}
func (m *TLAuthsessionSetAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionSetAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetAuthKey) GetAuthKey() *mtproto.AuthKeyInfo {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *TLAuthsessionSetAuthKey) GetFutureSalt() *mtproto.FutureSalt {
	if m != nil {
		return m.FutureSalt
	}
	return nil
}

func (m *TLAuthsessionSetAuthKey) GetExpiresIn() int32 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionBindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionBindAuthKeyUser) Reset()         { *m = TLAuthsessionBindAuthKeyUser{} }
func (m *TLAuthsessionBindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionBindAuthKeyUser) ProtoMessage()    {}
func (*TLAuthsessionBindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{15}
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionBindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionBindAuthKeyUser.Merge(m, src)
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionBindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionBindAuthKeyUser proto.InternalMessageInfo

func (m *TLAuthsessionBindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionBindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionBindAuthKeyUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionUnbindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionUnbindAuthKeyUser) Reset()         { *m = TLAuthsessionUnbindAuthKeyUser{} }
func (m *TLAuthsessionUnbindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionUnbindAuthKeyUser) ProtoMessage()    {}
func (*TLAuthsessionUnbindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{16}
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.Merge(m, src)
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser proto.InternalMessageInfo

func (m *TLAuthsessionUnbindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionUnbindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionUnbindAuthKeyUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetPermAuthKeyId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetPermAuthKeyId) Reset()         { *m = TLAuthsessionGetPermAuthKeyId{} }
func (m *TLAuthsessionGetPermAuthKeyId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetPermAuthKeyId) ProtoMessage()    {}
func (*TLAuthsessionGetPermAuthKeyId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{17}
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.Merge(m, src)
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetPermAuthKeyId proto.InternalMessageInfo

func (m *TLAuthsessionGetPermAuthKeyId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetPermAuthKeyId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionBindTempAuthKey struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	PermAuthKeyId        int64         `protobuf:"varint,3,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	Nonce                int64         `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ExpiresAt            int32         `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	EncryptedMessage     []byte        `protobuf:"bytes,6,opt,name=encrypted_message,json=encryptedMessage,proto3" json:"encrypted_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionBindTempAuthKey) Reset()         { *m = TLAuthsessionBindTempAuthKey{} }
func (m *TLAuthsessionBindTempAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionBindTempAuthKey) ProtoMessage()    {}
func (*TLAuthsessionBindTempAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{18}
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionBindTempAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionBindTempAuthKey.Merge(m, src)
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionBindTempAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionBindTempAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionBindTempAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionBindTempAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionBindTempAuthKey) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetExpiresAt() int32 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionSetClientSessionInfo struct {
	Constructor          TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	Data                 *ClientSession `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLAuthsessionSetClientSessionInfo) Reset()         { *m = TLAuthsessionSetClientSessionInfo{} }
func (m *TLAuthsessionSetClientSessionInfo) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetClientSessionInfo) ProtoMessage()    {}
func (*TLAuthsessionSetClientSessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{19}
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetClientSessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetClientSessionInfo.Merge(m, src)
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetClientSessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetClientSessionInfo proto.InternalMessageInfo

func (m *TLAuthsessionSetClientSessionInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetClientSessionInfo) GetData() *ClientSession {
	if m != nil {
		return m.Data
	}
	return nil
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthorization) Reset()         { *m = TLAuthsessionGetAuthorization{} }
func (m *TLAuthsessionGetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthorization) ProtoMessage()    {}
func (*TLAuthsessionGetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{20}
}
func (m *TLAuthsessionGetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthorization.Merge(m, src)
}
func (m *TLAuthsessionGetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthorization proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionGetAuthStateData struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthStateData) Reset()         { *m = TLAuthsessionGetAuthStateData{} }
func (m *TLAuthsessionGetAuthStateData) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthStateData) ProtoMessage()    {}
func (*TLAuthsessionGetAuthStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{21}
}
func (m *TLAuthsessionGetAuthStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthStateData.Merge(m, src)
}
func (m *TLAuthsessionGetAuthStateData) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthStateData.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthStateData proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthStateData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthStateData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionSetLayer struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Ip                   string        `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	Layer                int32         `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionSetLayer) Reset()         { *m = TLAuthsessionSetLayer{} }
func (m *TLAuthsessionSetLayer) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetLayer) ProtoMessage()    {}
func (*TLAuthsessionSetLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{22}
}
func (m *TLAuthsessionSetLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetLayer.Merge(m, src)
}
func (m *TLAuthsessionSetLayer) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetLayer proto.InternalMessageInfo

func (m *TLAuthsessionSetLayer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetLayer) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionSetLayer) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *TLAuthsessionSetLayer) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

//--------------------------------------------------------------------------------------------
type TLAuthsessionSetInitConnection struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Ip                   string        `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	ApiId                int32         `protobuf:"varint,5,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel          string        `protobuf:"bytes,6,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion        string        `protobuf:"bytes,7,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion           string        `protobuf:"bytes,8,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	SystemLangCode       string        `protobuf:"bytes,9,opt,name=system_lang_code,json=systemLangCode,proto3" json:"system_lang_code,omitempty"`
	LangPack             string        `protobuf:"bytes,10,opt,name=lang_pack,json=langPack,proto3" json:"lang_pack,omitempty"`
	LangCode             string        `protobuf:"bytes,11,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Proxy                string        `protobuf:"bytes,12,opt,name=proxy,proto3" json:"proxy,omitempty"`
	Params               string        `protobuf:"bytes,13,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionSetInitConnection) Reset()         { *m = TLAuthsessionSetInitConnection{} }
func (m *TLAuthsessionSetInitConnection) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetInitConnection) ProtoMessage()    {}
func (*TLAuthsessionSetInitConnection) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{23}
}
func (m *TLAuthsessionSetInitConnection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetInitConnection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetInitConnection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetInitConnection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetInitConnection.Merge(m, src)
}
func (m *TLAuthsessionSetInitConnection) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetInitConnection) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetInitConnection.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetInitConnection proto.InternalMessageInfo

func (m *TLAuthsessionSetInitConnection) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetInitConnection) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionSetInitConnection) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *TLAuthsessionSetInitConnection) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetSystemLangCode() string {
	if m != nil {
		return m.SystemLangCode
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetLangPack() string {
	if m != nil {
		return m.LangPack
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *TLAuthsessionSetInitConnection) GetParams() string {
	if m != nil {
		return m.Params
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_Long struct {
	Datas                []int64  `protobuf:"varint,1,rep,packed,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vector_Long) Reset()         { *m = Vector_Long{} }
func (m *Vector_Long) String() string { return proto.CompactTextString(m) }
func (*Vector_Long) ProtoMessage()    {}
func (*Vector_Long) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{24}
}
func (m *Vector_Long) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_Long) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_Long.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_Long) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_Long.Merge(m, src)
}
func (m *Vector_Long) XXX_Size() int {
	return m.Size()
}
func (m *Vector_Long) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_Long.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_Long proto.InternalMessageInfo

func (m *Vector_Long) GetDatas() []int64 {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("authsession.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*AuthKeyStateData)(nil), "authsession.AuthKeyStateData")
	proto.RegisterType((*TLAuthKeyStateData)(nil), "authsession.TL_authKeyStateData")
	proto.RegisterType((*ClientSession)(nil), "authsession.ClientSession")
	proto.RegisterType((*TLClientSession)(nil), "authsession.TL_clientSession")
	proto.RegisterType((*TLAuthsessionGetAuthorizations)(nil), "authsession.TL_authsession_getAuthorizations")
	proto.RegisterType((*TLAuthsessionResetAuthorization)(nil), "authsession.TL_authsession_resetAuthorization")
	proto.RegisterType((*TLAuthsessionGetLayer)(nil), "authsession.TL_authsession_getLayer")
	proto.RegisterType((*TLAuthsessionGetLangPack)(nil), "authsession.TL_authsession_getLangPack")
	proto.RegisterType((*TLAuthsessionGetClient)(nil), "authsession.TL_authsession_getClient")
	proto.RegisterType((*TLAuthsessionGetLangCode)(nil), "authsession.TL_authsession_getLangCode")
	proto.RegisterType((*TLAuthsessionGetUserId)(nil), "authsession.TL_authsession_getUserId")
	proto.RegisterType((*TLAuthsessionGetPushSessionId)(nil), "authsession.TL_authsession_getPushSessionId")
	proto.RegisterType((*TLAuthsessionGetFutureSalts)(nil), "authsession.TL_authsession_getFutureSalts")
	proto.RegisterType((*TLAuthsessionQueryAuthKey)(nil), "authsession.TL_authsession_queryAuthKey")
	proto.RegisterType((*TLAuthsessionSetAuthKey)(nil), "authsession.TL_authsession_setAuthKey")
	proto.RegisterType((*TLAuthsessionBindAuthKeyUser)(nil), "authsession.TL_authsession_bindAuthKeyUser")
	proto.RegisterType((*TLAuthsessionUnbindAuthKeyUser)(nil), "authsession.TL_authsession_unbindAuthKeyUser")
	proto.RegisterType((*TLAuthsessionGetPermAuthKeyId)(nil), "authsession.TL_authsession_getPermAuthKeyId")
	proto.RegisterType((*TLAuthsessionBindTempAuthKey)(nil), "authsession.TL_authsession_bindTempAuthKey")
	proto.RegisterType((*TLAuthsessionSetClientSessionInfo)(nil), "authsession.TL_authsession_setClientSessionInfo")
	proto.RegisterType((*TLAuthsessionGetAuthorization)(nil), "authsession.TL_authsession_getAuthorization")
	proto.RegisterType((*TLAuthsessionGetAuthStateData)(nil), "authsession.TL_authsession_getAuthStateData")
	proto.RegisterType((*TLAuthsessionSetLayer)(nil), "authsession.TL_authsession_setLayer")
	proto.RegisterType((*TLAuthsessionSetInitConnection)(nil), "authsession.TL_authsession_setInitConnection")
	proto.RegisterType((*Vector_Long)(nil), "authsession.Vector_Long")
}

func init() { proto.RegisterFile("authsession.tl.proto", fileDescriptor_7cbc1347c4a76ecf) }

var fileDescriptor_7cbc1347c4a76ecf = []byte{
	// 1861 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x5d, 0x6c, 0x23, 0x57,
	0x15, 0xf6, 0xc4, 0xb1, 0x13, 0x1f, 0xaf, 0xc3, 0xf4, 0xae, 0x9b, 0x75, 0x67, 0x1b, 0xaf, 0x77,
	0xb2, 0x3f, 0x61, 0x77, 0x93, 0x14, 0x6f, 0xe1, 0x01, 0xf1, 0x92, 0xa6, 0x02, 0x99, 0x66, 0x43,
	0x70, 0xb2, 0x45, 0xfc, 0xa8, 0xc3, 0xcd, 0xcc, 0x8d, 0x3d, 0x8a, 0x3d, 0x33, 0x9d, 0xb9, 0xde,
	0xc6, 0xe5, 0x01, 0xa9, 0xfc, 0xe5, 0xa1, 0x12, 0x42, 0xb4, 0x42, 0x7d, 0x00, 0x1e, 0xb2, 0xfc,
	0x54, 0xfc, 0x68, 0xe1, 0x05, 0x0a, 0x14, 0xa9, 0x52, 0x55, 0x2d, 0xe2, 0x47, 0x45, 0x42, 0x48,
	0x95, 0x90, 0xa0, 0xa9, 0xb4, 0x88, 0xbe, 0x50, 0x10, 0x0f, 0x4b, 0x51, 0x09, 0x9a, 0x3b, 0x63,
	0xcf, 0xaf, 0xc7, 0xa9, 0xb6, 0x66, 0xf7, 0x6d, 0xee, 0xbd, 0xdf, 0x3d, 0xe7, 0xdc, 0x73, 0xbe,
	0x7b, 0xee, 0x39, 0x36, 0x14, 0x71, 0x87, 0x36, 0x2d, 0x62, 0x59, 0xaa, 0xae, 0x2d, 0xd0, 0xd6,
	0x82, 0x61, 0xea, 0x54, 0x47, 0x79, 0xdf, 0xac, 0x30, 0xdf, 0x50, 0x69, 0xb3, 0xb3, 0xb9, 0x20,
	0xeb, 0xed, 0xc5, 0x86, 0xde, 0xd0, 0x17, 0x19, 0x66, 0xb3, 0xb3, 0xc5, 0x46, 0x6c, 0xc0, 0xbe,
	0x9c, 0xbd, 0x42, 0xb9, 0xa1, 0xeb, 0x8d, 0x16, 0xf1, 0x50, 0x8f, 0x99, 0xd8, 0x30, 0x88, 0x69,
	0xb9, 0xeb, 0x82, 0x25, 0x37, 0x49, 0x1b, 0xdb, 0xca, 0x64, 0xdd, 0x24, 0x12, 0xed, 0x1a, 0xa4,
	0xb7, 0x76, 0x8f, 0xb7, 0x46, 0x4d, 0xac, 0x59, 0x86, 0x6e, 0x52, 0x77, 0xa9, 0xe8, 0x2d, 0x59,
	0x5d, 0x4d, 0x76, 0x66, 0xc5, 0x9f, 0x8f, 0x01, 0xbf, 0xd4, 0xa1, 0xcd, 0x87, 0x48, 0x77, 0x9d,
	0x62, 0x4a, 0x1e, 0xc4, 0x14, 0xa3, 0xd3, 0x30, 0x65, 0x98, 0x44, 0x51, 0x65, 0x4c, 0x89, 0xa4,
	0xe1, 0x36, 0x29, 0x71, 0x15, 0x6e, 0x2e, 0x57, 0x2f, 0xf4, 0x67, 0x57, 0x71, 0x9b, 0xa0, 0x0f,
	0x40, 0x5e, 0xd6, 0x35, 0x8b, 0x9a, 0x1d, 0x99, 0xea, 0x66, 0x69, 0xac, 0xc2, 0xcd, 0x4d, 0x55,
	0x85, 0x05, 0xbf, 0x43, 0x36, 0x56, 0x96, 0x3d, 0x44, 0xdd, 0x0f, 0x47, 0x65, 0x60, 0x4e, 0x92,
	0xb6, 0x49, 0x57, 0x52, 0x95, 0x52, 0xba, 0xc2, 0xcd, 0xa5, 0xeb, 0x39, 0xec, 0xd8, 0x52, 0x53,
	0xd0, 0x31, 0x98, 0xe8, 0x58, 0xc4, 0xb4, 0xd7, 0xc6, 0xd9, 0x5a, 0xd6, 0x1e, 0xd6, 0x14, 0x74,
	0x1c, 0x72, 0xf6, 0x1e, 0xcb, 0x36, 0xb7, 0x94, 0xa9, 0x70, 0x73, 0x99, 0xfa, 0xe4, 0xb6, 0x6b,
	0x3e, 0x2a, 0x42, 0xa6, 0x85, 0xbb, 0xc4, 0x2c, 0x65, 0xd9, 0x82, 0x33, 0x40, 0x27, 0x20, 0x2f,
	0xb7, 0x54, 0xa2, 0x51, 0xe6, 0xac, 0xd2, 0x04, 0x5b, 0x03, 0x67, 0x6a, 0xa3, 0x6b, 0x10, 0xf4,
	0x5e, 0x38, 0x86, 0x35, 0xc5, 0xd4, 0x55, 0x45, 0x32, 0x3a, 0x56, 0x53, 0x72, 0xed, 0xb7, 0x95,
	0x4f, 0x32, 0xe5, 0x45, 0x77, 0x79, 0xad, 0x63, 0x35, 0xd7, 0x9d, 0xc5, 0x9a, 0x22, 0x7e, 0x18,
	0x8e, 0x6e, 0xac, 0x48, 0x38, 0xec, 0xbf, 0x8b, 0x90, 0x51, 0x30, 0xc5, 0x55, 0xe6, 0xb6, 0x7c,
	0x75, 0x26, 0xe0, 0x92, 0xb0, 0xb7, 0xeb, 0x0e, 0x56, 0xfc, 0x5d, 0x1a, 0x0a, 0xcb, 0xcc, 0x22,
	0x57, 0xfe, 0x9d, 0x11, 0x86, 0x29, 0x18, 0x53, 0x0d, 0x16, 0x81, 0x5c, 0x7d, 0x4c, 0x35, 0x3c,
	0x07, 0x67, 0xfc, 0x0e, 0xbe, 0x1b, 0xb2, 0xd8, 0x50, 0x6d, 0x01, 0xae, 0xdf, 0xb1, 0xa1, 0xd6,
	0x14, 0x74, 0x12, 0x8e, 0x28, 0xe4, 0x8a, 0x2a, 0x13, 0xa9, 0xad, 0x2b, 0xa4, 0xc5, 0x1c, 0x9f,
	0xab, 0xe7, 0x9d, 0xb9, 0x4b, 0xf6, 0x94, 0x7d, 0x48, 0xab, 0x6b, 0x51, 0xd2, 0x96, 0xae, 0x10,
	0xd3, 0x36, 0x96, 0x39, 0x3c, 0x57, 0x2f, 0x38, 0xb3, 0x0f, 0x3b, 0x93, 0x76, 0x04, 0xb1, 0x61,
	0xf4, 0x31, 0x39, 0x86, 0x01, 0x6c, 0x18, 0x3d, 0xc0, 0x1c, 0xf0, 0xae, 0x9c, 0x16, 0xd6, 0x1a,
	0x92, 0xac, 0x2b, 0xa4, 0x04, 0x0c, 0xe5, 0xca, 0x5f, 0xc1, 0x5a, 0x63, 0x59, 0x57, 0x88, 0xcd,
	0x1f, 0x06, 0x31, 0xb0, 0xbc, 0x5d, 0xca, 0x33, 0xc8, 0xa4, 0x3d, 0xb1, 0x86, 0xe5, 0xed, 0xfe,
	0x22, 0xdb, 0x7f, 0xc4, 0x5b, 0x64, 0x3b, 0x8b, 0x90, 0x31, 0x4c, 0x7d, 0xa7, 0x5b, 0x2a, 0xb0,
	0x05, 0x67, 0x80, 0xa6, 0x21, 0x6b, 0x60, 0x13, 0xb7, 0xad, 0xd2, 0x14, 0x9b, 0x76, 0x47, 0xe2,
	0x83, 0xc0, 0x6f, 0xac, 0x48, 0x72, 0x20, 0xa4, 0xf7, 0x05, 0x99, 0x11, 0x8c, 0x52, 0x20, 0xfa,
	0x3d, 0x5a, 0x7c, 0x87, 0x83, 0x8a, 0xcb, 0xb1, 0x1e, 0x29, 0x1b, 0x84, 0xda, 0x24, 0xd2, 0x4d,
	0xf5, 0x71, 0x4c, 0x55, 0x5d, 0xb3, 0xc2, 0x14, 0xe0, 0xde, 0x1e, 0x05, 0x7c, 0x37, 0x2d, 0x1d,
	0xb8, 0x69, 0x17, 0x00, 0x91, 0x1d, 0xb9, 0xd5, 0x51, 0x88, 0xd4, 0xe3, 0x48, 0xad, 0x77, 0x1b,
	0x79, 0x77, 0x65, 0xa9, 0xc7, 0x14, 0xf1, 0x87, 0x1c, 0x9c, 0x0c, 0x59, 0x6a, 0x12, 0x2b, 0x64,
	0xeb, 0xa8, 0x4c, 0x0d, 0xd1, 0x78, 0x3c, 0x4c, 0x63, 0x04, 0xe3, 0x4d, 0x6c, 0x35, 0x19, 0x6b,
	0xd3, 0x75, 0xf6, 0x2d, 0x3e, 0x06, 0xc7, 0xa2, 0x9e, 0x5d, 0x61, 0x7c, 0xbe, 0x35, 0x2b, 0x87,
	0xdc, 0x29, 0xf1, 0x71, 0x10, 0xe2, 0x14, 0xbb, 0x14, 0x1c, 0xad, 0xee, 0x1d, 0x28, 0x45, 0x75,
	0x3b, 0xcc, 0xbb, 0x5d, 0xa7, 0x66, 0x77, 0xeb, 0x36, 0x9c, 0xfa, 0xb2, 0x43, 0x9d, 0xd1, 0x6a,
	0xfe, 0x09, 0x07, 0x27, 0xa2, 0xaa, 0x03, 0xcf, 0xc8, 0xed, 0xba, 0x13, 0x33, 0x00, 0x54, 0xdf,
	0x26, 0x9a, 0xf3, 0x28, 0x3a, 0xf9, 0x3c, 0xc7, 0x66, 0xec, 0x37, 0x51, 0xfc, 0x32, 0x07, 0x33,
	0x51, 0xcb, 0x3f, 0xd8, 0xa1, 0x1d, 0x93, 0xac, 0xe3, 0x16, 0xb5, 0x46, 0xeb, 0x39, 0xc4, 0x43,
	0x5a, 0xeb, 0xb4, 0x99, 0xd9, 0x99, 0xba, 0xfd, 0x29, 0x7e, 0x06, 0x8e, 0x87, 0x0c, 0x7a, 0xb4,
	0x43, 0xcc, 0xae, 0x9b, 0x82, 0x46, 0x1c, 0xc8, 0x3f, 0x73, 0x70, 0x4f, 0x48, 0xbb, 0x9b, 0xdc,
	0x6e, 0x5d, 0xf7, 0x22, 0x4c, 0xf6, 0x74, 0x33, 0xc5, 0xf9, 0x6a, 0x71, 0xa1, 0x4d, 0x59, 0x85,
	0xd6, 0xab, 0x17, 0x6a, 0xda, 0x96, 0x5e, 0x9f, 0x70, 0xcd, 0x41, 0xf7, 0x43, 0x7e, 0x8b, 0x05,
	0x42, 0xb2, 0x70, 0x8b, 0x32, 0x1f, 0xe5, 0xab, 0x47, 0xfb, 0x7b, 0xbc, 0x20, 0xd5, 0x61, 0xab,
	0xff, 0x6d, 0x07, 0x9c, 0xec, 0x18, 0xaa, 0x49, 0x2c, 0x49, 0xd5, 0x7a, 0x01, 0x77, 0x67, 0x6a,
	0x9a, 0xf8, 0x35, 0x0e, 0xca, 0xa1, 0x13, 0x6e, 0xaa, 0x9a, 0xe2, 0x1a, 0x60, 0xdf, 0x96, 0x11,
	0x47, 0x7c, 0x50, 0xc9, 0x27, 0x3e, 0x13, 0x7d, 0x04, 0x3b, 0xda, 0x1d, 0x62, 0xdb, 0x67, 0x63,
	0xef, 0x37, 0x31, 0xdb, 0xfd, 0x97, 0x71, 0xc4, 0xc4, 0xfc, 0x5b, 0x7c, 0xd8, 0x36, 0x48, 0xdb,
	0x78, 0x67, 0xd8, 0x79, 0x16, 0x78, 0x83, 0x98, 0x6d, 0x29, 0x6a, 0x45, 0xc1, 0x08, 0x9c, 0xb3,
	0x08, 0x19, 0x4d, 0xd7, 0x64, 0xe2, 0x7a, 0xc8, 0x19, 0xf8, 0x59, 0x87, 0x69, 0x88, 0x75, 0x4b,
	0x14, 0x9d, 0x87, 0xbb, 0x88, 0x26, 0x9b, 0x5d, 0x83, 0x12, 0x45, 0x6a, 0x13, 0xcb, 0xc2, 0x0d,
	0xc2, 0xaa, 0xc8, 0x23, 0x75, 0xbe, 0xbf, 0x70, 0xc9, 0x99, 0x17, 0xbf, 0xca, 0xc1, 0x6c, 0xf4,
	0x12, 0x06, 0x0a, 0x27, 0xfb, 0xa2, 0xdc, 0xe2, 0x81, 0x17, 0x60, 0xdc, 0x2e, 0xbe, 0xdc, 0xab,
	0x98, 0x54, 0xa4, 0x31, 0x5c, 0x3c, 0x05, 0xde, 0xc9, 0xb2, 0x67, 0x18, 0x05, 0x06, 0x1a, 0xe0,
	0xf5, 0x24, 0xa3, 0x35, 0xe0, 0xeb, 0x5c, 0xa4, 0x96, 0xb2, 0xfe, 0x2f, 0xb5, 0xd4, 0xe1, 0xfa,
	0x13, 0xf1, 0x6a, 0x3a, 0x92, 0x40, 0x2c, 0x42, 0x6b, 0x9a, 0x4a, 0x97, 0x75, 0x4d, 0x23, 0xf2,
	0xe8, 0x63, 0x14, 0x31, 0xd4, 0x6b, 0x99, 0x32, 0x49, 0x2d, 0x53, 0xf6, 0x30, 0x2d, 0xd3, 0xc4,
	0x21, 0x5a, 0xa6, 0xc9, 0x43, 0xb5, 0x4c, 0xb9, 0xe1, 0x2d, 0x13, 0x24, 0xb5, 0x4c, 0xf9, 0x41,
	0x2d, 0xd3, 0x91, 0xf8, 0x96, 0xa9, 0x10, 0x68, 0x99, 0x66, 0x21, 0xff, 0x30, 0xb1, 0xbd, 0x29,
	0xad, 0xe8, 0x5a, 0xc3, 0xde, 0x6c, 0xdf, 0x2f, 0xab, 0xc4, 0x55, 0xd2, 0x76, 0x3e, 0x61, 0x83,
	0x73, 0xd7, 0x27, 0xa0, 0x10, 0x88, 0x03, 0xba, 0x0b, 0x0a, 0xcb, 0xf5, 0xe5, 0x8b, 0x55, 0xe9,
	0xf2, 0xea, 0x43, 0xab, 0x1f, 0xf9, 0xd8, 0x2a, 0x9f, 0x42, 0x15, 0x38, 0xea, 0x4c, 0x05, 0xfa,
	0x2f, 0xfe, 0xda, 0x6b, 0xcf, 0xfd, 0xe1, 0xdf, 0x07, 0x07, 0x07, 0x07, 0x1c, 0x9a, 0x85, 0x69,
	0x07, 0x11, 0x6e, 0xdf, 0xf9, 0x6b, 0xbf, 0x79, 0xe9, 0xd7, 0x6f, 0x39, 0xa0, 0xf3, 0x30, 0xeb,
	0x81, 0x06, 0xf6, 0x5f, 0xfc, 0x8b, 0x57, 0x77, 0xbf, 0x94, 0x46, 0xef, 0x81, 0x53, 0x51, 0x70,
	0xb4, 0x05, 0xe2, 0xbf, 0xfd, 0xca, 0x5b, 0xaf, 0xdf, 0x74, 0xe4, 0x9f, 0x05, 0x21, 0x56, 0x3e,
	0xbb, 0x39, 0xfc, 0xb3, 0x3f, 0xf8, 0xc5, 0x0b, 0x6f, 0x3a, 0xc0, 0xd3, 0x30, 0x33, 0x00, 0xe8,
	0x44, 0x81, 0xbf, 0xf1, 0xc4, 0xdf, 0x7f, 0x3b, 0x86, 0x66, 0xe1, 0x78, 0x2c, 0xcc, 0xc9, 0x5a,
	0xfc, 0x2f, 0xbf, 0xf7, 0xea, 0x13, 0xd9, 0x44, 0x59, 0x76, 0xd0, 0xf8, 0x57, 0x5e, 0xbf, 0xf1,
	0x62, 0x66, 0xa0, 0x2c, 0xa7, 0x6c, 0xe6, 0xbf, 0xff, 0xdc, 0xd5, 0x9f, 0x65, 0xd0, 0x22, 0x88,
	0xb1, 0xa0, 0x40, 0x81, 0xcb, 0xbf, 0xb0, 0xbf, 0xfb, 0x8d, 0xff, 0x38, 0x07, 0x99, 0x87, 0x4a,
	0xec, 0x06, 0x5f, 0x5d, 0xc9, 0x3f, 0x7d, 0xed, 0xf9, 0x97, 0x5c, 0xf8, 0x19, 0x28, 0x47, 0xe1,
	0xfe, 0xaa, 0x8f, 0xff, 0xee, 0x1b, 0x7f, 0xfa, 0x56, 0x06, 0x9d, 0x82, 0x7b, 0xa3, 0x38, 0xaf,
	0x3e, 0xe3, 0xbf, 0xf2, 0xcc, 0xcb, 0xff, 0x4a, 0xa3, 0x39, 0x38, 0x19, 0x45, 0x85, 0xea, 0x08,
	0x7e, 0x6f, 0xf7, 0xa7, 0x8f, 0xa0, 0x73, 0x71, 0x81, 0x8f, 0xd4, 0x1c, 0xfc, 0xf5, 0x27, 0x5f,
	0x7b, 0xff, 0x60, 0x1f, 0xf8, 0x1f, 0x47, 0xfe, 0x8f, 0xbf, 0xfa, 0xfd, 0xe7, 0x5c, 0xea, 0xbd,
	0x7b, 0x90, 0x19, 0xbe, 0x37, 0x9b, 0xff, 0xe2, 0x37, 0x9f, 0xff, 0x7c, 0x16, 0xcd, 0xc3, 0x99,
	0xd8, 0x73, 0x45, 0x9e, 0x3c, 0xfe, 0xa9, 0x83, 0xbf, 0x4e, 0xa3, 0x73, 0x03, 0x4c, 0x09, 0x12,
	0x70, 0xef, 0xc7, 0x37, 0xff, 0x99, 0x4d, 0xc4, 0x7a, 0x97, 0xe1, 0x47, 0xfb, 0x37, 0xdf, 0x1c,
	0x47, 0x62, 0x1c, 0x4f, 0x7b, 0x19, 0x9e, 0xff, 0xc2, 0xb3, 0x4f, 0xed, 0x8d, 0xc7, 0xdf, 0x95,
	0x48, 0x96, 0xe5, 0x9f, 0x7c, 0xfa, 0xbf, 0x37, 0x26, 0x84, 0xf1, 0xdd, 0xbd, 0x72, 0xaa, 0xfa,
	0x8f, 0x29, 0x98, 0xaa, 0xaf, 0x2d, 0x2f, 0x79, 0x1b, 0xd0, 0xa3, 0x30, 0x93, 0xfc, 0x5b, 0xc7,
	0x7c, 0x28, 0x21, 0x27, 0x5f, 0x4d, 0xe1, 0x44, 0xbf, 0x28, 0xc6, 0xb2, 0xac, 0x77, 0x34, 0x2a,
	0x05, 0x01, 0x62, 0x0a, 0xb5, 0xa0, 0x3c, 0xe4, 0x47, 0x8b, 0x85, 0x24, 0x9d, 0x51, 0xbc, 0x50,
	0x0a, 0xe0, 0x7d, 0x29, 0x4d, 0x4c, 0xa1, 0xd5, 0xc0, 0x4f, 0xc6, 0xde, 0x4f, 0x0e, 0xa7, 0x86,
	0x9c, 0x8b, 0xa1, 0x84, 0xa9, 0xfe, 0x71, 0x6a, 0x1a, 0xbd, 0x58, 0x15, 0x53, 0xe8, 0x32, 0x1c,
	0x1b, 0xf4, 0x4b, 0xc2, 0xd9, 0xa1, 0x22, 0x1d, 0xa0, 0xf0, 0xae, 0xbe, 0xd4, 0x75, 0x6a, 0xaa,
	0xcc, 0xcc, 0x8f, 0xc2, 0xdd, 0xf1, 0x3f, 0x12, 0x9c, 0x1e, 0x22, 0xd4, 0x81, 0xc5, 0x89, 0x8c,
	0xb7, 0x94, 0x3d, 0x13, 0x87, 0xb1, 0xd4, 0x06, 0xc6, 0x89, 0x5d, 0x8b, 0x58, 0xea, 0x36, 0xf6,
	0xc3, 0x2c, 0x75, 0x60, 0x41, 0x97, 0xbe, 0xef, 0x7e, 0x31, 0x85, 0x1e, 0x81, 0x7b, 0x13, 0xfb,
	0xf5, 0x0b, 0x43, 0x04, 0x07, 0xd0, 0x31, 0xf2, 0x3f, 0x0d, 0x42, 0x42, 0x57, 0x7d, 0x6e, 0x88,
	0x74, 0x1f, 0x56, 0x28, 0xc6, 0xb4, 0x7c, 0x36, 0xa5, 0x3f, 0x05, 0xa5, 0x81, 0x6d, 0xf2, 0x5c,
	0x92, 0x7c, 0x3f, 0x52, 0x88, 0x6d, 0x42, 0x19, 0x37, 0xa6, 0x07, 0xb4, 0xc1, 0x67, 0x92, 0x64,
	0x7b, 0x38, 0xa1, 0xd0, 0x97, 0xfc, 0x80, 0xae, 0xb7, 0x98, 0xc1, 0xc7, 0x93, 0xfa, 0xce, 0xf3,
	0x49, 0x72, 0x43, 0xe0, 0x18, 0x87, 0x4b, 0xc1, 0xa4, 0x12, 0xed, 0x1d, 0x13, 0x93, 0x4a, 0x04,
	0x1e, 0x35, 0x3f, 0x86, 0x31, 0x81, 0xce, 0x68, 0x28, 0x63, 0xfc, 0xe8, 0x98, 0x03, 0x7c, 0x32,
	0xea, 0x1e, 0x7f, 0x7f, 0x37, 0xd4, 0x3d, 0x3e, 0x70, 0xd4, 0x78, 0x02, 0x95, 0xa1, 0x0d, 0xd5,
	0x7d, 0x43, 0x02, 0x1b, 0xd9, 0x11, 0x55, 0xb3, 0x15, 0xf1, 0x51, 0x30, 0xc9, 0x5e, 0x78, 0x3b,
	0x89, 0x5d, 0x98, 0x0e, 0x70, 0xb3, 0x3f, 0x2f, 0xa6, 0x50, 0x3b, 0x56, 0x8f, 0xd7, 0x09, 0x1d,
	0x46, 0x4f, 0x1f, 0x2d, 0x24, 0xff, 0x79, 0x23, 0xa6, 0xd0, 0xa5, 0x60, 0x3e, 0xb7, 0x0e, 0x95,
	0xcf, 0x7b, 0xa8, 0xa8, 0x97, 0x42, 0x54, 0x8d, 0x76, 0x29, 0xf3, 0x43, 0xe4, 0x06, 0xe1, 0x11,
	0x05, 0x0f, 0x7c, 0xfc, 0x8d, 0x57, 0xcb, 0xdc, 0xf5, 0xfd, 0x32, 0xf7, 0xf2, 0x7e, 0x99, 0xfb,
	0xcb, 0x7e, 0x99, 0xfb, 0xc4, 0x87, 0x7c, 0xff, 0x4f, 0x52, 0x82, 0xdb, 0x0d, 0x13, 0x7b, 0x1f,
	0xf3, 0x16, 0x31, 0xaf, 0x10, 0x73, 0x11, 0x1b, 0xc6, 0xa2, 0xfd, 0xa9, 0xca, 0x64, 0xd1, 0xa7,
	0xd1, 0xff, 0xbd, 0x99, 0x65, 0x8a, 0x2e, 0xfe, 0x2f, 0x00, 0x00, 0xff, 0xff, 0x11, 0x7d, 0x80,
	0x69, 0x14, 0x1d, 0x00, 0x00,
}

func (this *AuthKeyStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&authsession.AuthKeyStateData{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "KeyState: "+fmt.Sprintf("%#v", this.KeyState)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "ClientType: "+fmt.Sprintf("%#v", this.ClientType)+",\n")
	s = append(s, "AndroidPushSessionId: "+fmt.Sprintf("%#v", this.AndroidPushSessionId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthKeyStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.TLAuthKeyStateData{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ClientSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&authsession.ClientSession{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "ApiId: "+fmt.Sprintf("%#v", this.ApiId)+",\n")
	s = append(s, "DeviceModel: "+fmt.Sprintf("%#v", this.DeviceModel)+",\n")
	s = append(s, "SystemVersion: "+fmt.Sprintf("%#v", this.SystemVersion)+",\n")
	s = append(s, "AppVersion: "+fmt.Sprintf("%#v", this.AppVersion)+",\n")
	s = append(s, "SystemLangCode: "+fmt.Sprintf("%#v", this.SystemLangCode)+",\n")
	s = append(s, "LangPack: "+fmt.Sprintf("%#v", this.LangPack)+",\n")
	s = append(s, "LangCode: "+fmt.Sprintf("%#v", this.LangCode)+",\n")
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLClientSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.TLClientSession{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthorizations) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionGetAuthorizations{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ExcludeAuthKeyId: "+fmt.Sprintf("%#v", this.ExcludeAuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionResetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionResetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLayer{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLangPack) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLangPack{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetClient{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLangCode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLangCode{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetUserId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetUserId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetPushSessionId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionGetPushSessionId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetFutureSalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionGetFutureSalts{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionQueryAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionQueryAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionSetAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.AuthKey != nil {
		s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",\n")
	}
	if this.FutureSalt != nil {
		s = append(s, "FutureSalt: "+fmt.Sprintf("%#v", this.FutureSalt)+",\n")
	}
	s = append(s, "ExpiresIn: "+fmt.Sprintf("%#v", this.ExpiresIn)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionBindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionBindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionUnbindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionUnbindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetPermAuthKeyId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetPermAuthKeyId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionBindTempAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&authsession.TLAuthsessionBindTempAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "PermAuthKeyId: "+fmt.Sprintf("%#v", this.PermAuthKeyId)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "ExpiresAt: "+fmt.Sprintf("%#v", this.ExpiresAt)+",\n")
	s = append(s, "EncryptedMessage: "+fmt.Sprintf("%#v", this.EncryptedMessage)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetClientSessionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionSetClientSessionInfo{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetAuthStateData{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetLayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionSetLayer{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetInitConnection) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&authsession.TLAuthsessionSetInitConnection{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "ApiId: "+fmt.Sprintf("%#v", this.ApiId)+",\n")
	s = append(s, "DeviceModel: "+fmt.Sprintf("%#v", this.DeviceModel)+",\n")
	s = append(s, "SystemVersion: "+fmt.Sprintf("%#v", this.SystemVersion)+",\n")
	s = append(s, "AppVersion: "+fmt.Sprintf("%#v", this.AppVersion)+",\n")
	s = append(s, "SystemLangCode: "+fmt.Sprintf("%#v", this.SystemLangCode)+",\n")
	s = append(s, "LangPack: "+fmt.Sprintf("%#v", this.LangPack)+",\n")
	s = append(s, "LangCode: "+fmt.Sprintf("%#v", this.LangCode)+",\n")
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_Long) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.Vector_Long{")
	s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAuthsessionTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCAuthsessionClient is the client API for RPCAuthsession service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCAuthsessionClient interface {
	AuthsessionGetAuthorizations(ctx context.Context, in *TLAuthsessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error)
	AuthsessionResetAuthorization(ctx context.Context, in *TLAuthsessionResetAuthorization, opts ...grpc.CallOption) (*Vector_Long, error)
	AuthsessionGetLayer(ctx context.Context, in *TLAuthsessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error)
	AuthsessionGetLangPack(ctx context.Context, in *TLAuthsessionGetLangPack, opts ...grpc.CallOption) (*mtproto.String, error)
	AuthsessionGetClient(ctx context.Context, in *TLAuthsessionGetClient, opts ...grpc.CallOption) (*mtproto.String, error)
	AuthsessionGetLangCode(ctx context.Context, in *TLAuthsessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error)
	AuthsessionGetUserId(ctx context.Context, in *TLAuthsessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	AuthsessionGetPushSessionId(ctx context.Context, in *TLAuthsessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	AuthsessionGetFutureSalts(ctx context.Context, in *TLAuthsessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error)
	AuthsessionQueryAuthKey(ctx context.Context, in *TLAuthsessionQueryAuthKey, opts ...grpc.CallOption) (*mtproto.AuthKeyInfo, error)
	AuthsessionSetAuthKey(ctx context.Context, in *TLAuthsessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
	AuthsessionBindAuthKeyUser(ctx context.Context, in *TLAuthsessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error)
	AuthsessionUnbindAuthKeyUser(ctx context.Context, in *TLAuthsessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error)
	AuthsessionGetPermAuthKeyId(ctx context.Context, in *TLAuthsessionGetPermAuthKeyId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	AuthsessionBindTempAuthKey(ctx context.Context, in *TLAuthsessionBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
	AuthsessionSetClientSessionInfo(ctx context.Context, in *TLAuthsessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error)
	AuthsessionGetAuthorization(ctx context.Context, in *TLAuthsessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error)
	AuthsessionGetAuthStateData(ctx context.Context, in *TLAuthsessionGetAuthStateData, opts ...grpc.CallOption) (*AuthKeyStateData, error)
	AuthsessionSetLayer(ctx context.Context, in *TLAuthsessionSetLayer, opts ...grpc.CallOption) (*mtproto.Bool, error)
	AuthsessionSetInitConnection(ctx context.Context, in *TLAuthsessionSetInitConnection, opts ...grpc.CallOption) (*mtproto.Bool, error)
}

type rPCAuthsessionClient struct {
	cc *grpc.ClientConn
}

func NewRPCAuthsessionClient(cc *grpc.ClientConn) RPCAuthsessionClient {
	return &rPCAuthsessionClient{cc}
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthorizations(ctx context.Context, in *TLAuthsessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error) {
	out := new(mtproto.Account_Authorizations)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthorizations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionResetAuthorization(ctx context.Context, in *TLAuthsessionResetAuthorization, opts ...grpc.CallOption) (*Vector_Long, error) {
	out := new(Vector_Long)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_resetAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLayer(ctx context.Context, in *TLAuthsessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error) {
	out := new(mtproto.Int32)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLangPack(ctx context.Context, in *TLAuthsessionGetLangPack, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLangPack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetClient(ctx context.Context, in *TLAuthsessionGetClient, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLangCode(ctx context.Context, in *TLAuthsessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLangCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetUserId(ctx context.Context, in *TLAuthsessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetPushSessionId(ctx context.Context, in *TLAuthsessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getPushSessionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetFutureSalts(ctx context.Context, in *TLAuthsessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error) {
	out := new(mtproto.FutureSalts)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getFutureSalts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionQueryAuthKey(ctx context.Context, in *TLAuthsessionQueryAuthKey, opts ...grpc.CallOption) (*mtproto.AuthKeyInfo, error) {
	out := new(mtproto.AuthKeyInfo)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_queryAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetAuthKey(ctx context.Context, in *TLAuthsessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionBindAuthKeyUser(ctx context.Context, in *TLAuthsessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_bindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionUnbindAuthKeyUser(ctx context.Context, in *TLAuthsessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_unbindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetPermAuthKeyId(ctx context.Context, in *TLAuthsessionGetPermAuthKeyId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getPermAuthKeyId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionBindTempAuthKey(ctx context.Context, in *TLAuthsessionBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_bindTempAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetClientSessionInfo(ctx context.Context, in *TLAuthsessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setClientSessionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthorization(ctx context.Context, in *TLAuthsessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error) {
	out := new(mtproto.Authorization)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthStateData(ctx context.Context, in *TLAuthsessionGetAuthStateData, opts ...grpc.CallOption) (*AuthKeyStateData, error) {
	out := new(AuthKeyStateData)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthStateData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetLayer(ctx context.Context, in *TLAuthsessionSetLayer, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setLayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetInitConnection(ctx context.Context, in *TLAuthsessionSetInitConnection, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setInitConnection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCAuthsessionServer is the server API for RPCAuthsession service.
type RPCAuthsessionServer interface {
	AuthsessionGetAuthorizations(context.Context, *TLAuthsessionGetAuthorizations) (*mtproto.Account_Authorizations, error)
	AuthsessionResetAuthorization(context.Context, *TLAuthsessionResetAuthorization) (*Vector_Long, error)
	AuthsessionGetLayer(context.Context, *TLAuthsessionGetLayer) (*mtproto.Int32, error)
	AuthsessionGetLangPack(context.Context, *TLAuthsessionGetLangPack) (*mtproto.String, error)
	AuthsessionGetClient(context.Context, *TLAuthsessionGetClient) (*mtproto.String, error)
	AuthsessionGetLangCode(context.Context, *TLAuthsessionGetLangCode) (*mtproto.String, error)
	AuthsessionGetUserId(context.Context, *TLAuthsessionGetUserId) (*mtproto.Int64, error)
	AuthsessionGetPushSessionId(context.Context, *TLAuthsessionGetPushSessionId) (*mtproto.Int64, error)
	AuthsessionGetFutureSalts(context.Context, *TLAuthsessionGetFutureSalts) (*mtproto.FutureSalts, error)
	AuthsessionQueryAuthKey(context.Context, *TLAuthsessionQueryAuthKey) (*mtproto.AuthKeyInfo, error)
	AuthsessionSetAuthKey(context.Context, *TLAuthsessionSetAuthKey) (*mtproto.Bool, error)
	AuthsessionBindAuthKeyUser(context.Context, *TLAuthsessionBindAuthKeyUser) (*mtproto.Int64, error)
	AuthsessionUnbindAuthKeyUser(context.Context, *TLAuthsessionUnbindAuthKeyUser) (*mtproto.Bool, error)
	AuthsessionGetPermAuthKeyId(context.Context, *TLAuthsessionGetPermAuthKeyId) (*mtproto.Int64, error)
	AuthsessionBindTempAuthKey(context.Context, *TLAuthsessionBindTempAuthKey) (*mtproto.Bool, error)
	AuthsessionSetClientSessionInfo(context.Context, *TLAuthsessionSetClientSessionInfo) (*mtproto.Bool, error)
	AuthsessionGetAuthorization(context.Context, *TLAuthsessionGetAuthorization) (*mtproto.Authorization, error)
	AuthsessionGetAuthStateData(context.Context, *TLAuthsessionGetAuthStateData) (*AuthKeyStateData, error)
	AuthsessionSetLayer(context.Context, *TLAuthsessionSetLayer) (*mtproto.Bool, error)
	AuthsessionSetInitConnection(context.Context, *TLAuthsessionSetInitConnection) (*mtproto.Bool, error)
}

// UnimplementedRPCAuthsessionServer can be embedded to have forward compatible implementations.
type UnimplementedRPCAuthsessionServer struct {
}

func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthorizations(ctx context.Context, req *TLAuthsessionGetAuthorizations) (*mtproto.Account_Authorizations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthorizations not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionResetAuthorization(ctx context.Context, req *TLAuthsessionResetAuthorization) (*Vector_Long, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionResetAuthorization not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLayer(ctx context.Context, req *TLAuthsessionGetLayer) (*mtproto.Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLayer not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLangPack(ctx context.Context, req *TLAuthsessionGetLangPack) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLangPack not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetClient(ctx context.Context, req *TLAuthsessionGetClient) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetClient not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLangCode(ctx context.Context, req *TLAuthsessionGetLangCode) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLangCode not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetUserId(ctx context.Context, req *TLAuthsessionGetUserId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetUserId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetPushSessionId(ctx context.Context, req *TLAuthsessionGetPushSessionId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetPushSessionId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetFutureSalts(ctx context.Context, req *TLAuthsessionGetFutureSalts) (*mtproto.FutureSalts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetFutureSalts not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionQueryAuthKey(ctx context.Context, req *TLAuthsessionQueryAuthKey) (*mtproto.AuthKeyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionQueryAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetAuthKey(ctx context.Context, req *TLAuthsessionSetAuthKey) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionBindAuthKeyUser(ctx context.Context, req *TLAuthsessionBindAuthKeyUser) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionBindAuthKeyUser not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionUnbindAuthKeyUser(ctx context.Context, req *TLAuthsessionUnbindAuthKeyUser) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionUnbindAuthKeyUser not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetPermAuthKeyId(ctx context.Context, req *TLAuthsessionGetPermAuthKeyId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetPermAuthKeyId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionBindTempAuthKey(ctx context.Context, req *TLAuthsessionBindTempAuthKey) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionBindTempAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetClientSessionInfo(ctx context.Context, req *TLAuthsessionSetClientSessionInfo) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetClientSessionInfo not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthorization(ctx context.Context, req *TLAuthsessionGetAuthorization) (*mtproto.Authorization, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthorization not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthStateData(ctx context.Context, req *TLAuthsessionGetAuthStateData) (*AuthKeyStateData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthStateData not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetLayer(ctx context.Context, req *TLAuthsessionSetLayer) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetLayer not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetInitConnection(ctx context.Context, req *TLAuthsessionSetInitConnection) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetInitConnection not implemented")
}

func RegisterRPCAuthsessionServer(s *grpc.Server, srv RPCAuthsessionServer) {
	s.RegisterService(&_RPCAuthsession_serviceDesc, srv)
}

func _RPCAuthsession_AuthsessionGetAuthorizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthorizations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthorizations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorizations(ctx, req.(*TLAuthsessionGetAuthorizations))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionResetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionResetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionResetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionResetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionResetAuthorization(ctx, req.(*TLAuthsessionResetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLayer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLayer(ctx, req.(*TLAuthsessionGetLayer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLangPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLangPack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangPack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLangPack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangPack(ctx, req.(*TLAuthsessionGetLangPack))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetClient(ctx, req.(*TLAuthsessionGetClient))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLangCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLangCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLangCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangCode(ctx, req.(*TLAuthsessionGetLangCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetUserId(ctx, req.(*TLAuthsessionGetUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetPushSessionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetPushSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetPushSessionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetPushSessionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetPushSessionId(ctx, req.(*TLAuthsessionGetPushSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetFutureSalts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetFutureSalts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetFutureSalts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetFutureSalts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetFutureSalts(ctx, req.(*TLAuthsessionGetFutureSalts))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionQueryAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionQueryAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionQueryAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionQueryAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionQueryAuthKey(ctx, req.(*TLAuthsessionQueryAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetAuthKey(ctx, req.(*TLAuthsessionSetAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionBindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionBindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionBindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionBindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionBindAuthKeyUser(ctx, req.(*TLAuthsessionBindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionUnbindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionUnbindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionUnbindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionUnbindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionUnbindAuthKeyUser(ctx, req.(*TLAuthsessionUnbindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetPermAuthKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetPermAuthKeyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetPermAuthKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetPermAuthKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetPermAuthKeyId(ctx, req.(*TLAuthsessionGetPermAuthKeyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionBindTempAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionBindTempAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionBindTempAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionBindTempAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionBindTempAuthKey(ctx, req.(*TLAuthsessionBindTempAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetClientSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetClientSessionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetClientSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetClientSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetClientSessionInfo(ctx, req.(*TLAuthsessionSetClientSessionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorization(ctx, req.(*TLAuthsessionGetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetAuthStateData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthStateData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthStateData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthStateData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthStateData(ctx, req.(*TLAuthsessionGetAuthStateData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetLayer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetLayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetLayer(ctx, req.(*TLAuthsessionSetLayer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetInitConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetInitConnection)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetInitConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetInitConnection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetInitConnection(ctx, req.(*TLAuthsessionSetInitConnection))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCAuthsession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authsession.RPCAuthsession",
	HandlerType: (*RPCAuthsessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "authsession_getAuthorizations",
			Handler:    _RPCAuthsession_AuthsessionGetAuthorizations_Handler,
		},
		{
			MethodName: "authsession_resetAuthorization",
			Handler:    _RPCAuthsession_AuthsessionResetAuthorization_Handler,
		},
		{
			MethodName: "authsession_getLayer",
			Handler:    _RPCAuthsession_AuthsessionGetLayer_Handler,
		},
		{
			MethodName: "authsession_getLangPack",
			Handler:    _RPCAuthsession_AuthsessionGetLangPack_Handler,
		},
		{
			MethodName: "authsession_getClient",
			Handler:    _RPCAuthsession_AuthsessionGetClient_Handler,
		},
		{
			MethodName: "authsession_getLangCode",
			Handler:    _RPCAuthsession_AuthsessionGetLangCode_Handler,
		},
		{
			MethodName: "authsession_getUserId",
			Handler:    _RPCAuthsession_AuthsessionGetUserId_Handler,
		},
		{
			MethodName: "authsession_getPushSessionId",
			Handler:    _RPCAuthsession_AuthsessionGetPushSessionId_Handler,
		},
		{
			MethodName: "authsession_getFutureSalts",
			Handler:    _RPCAuthsession_AuthsessionGetFutureSalts_Handler,
		},
		{
			MethodName: "authsession_queryAuthKey",
			Handler:    _RPCAuthsession_AuthsessionQueryAuthKey_Handler,
		},
		{
			MethodName: "authsession_setAuthKey",
			Handler:    _RPCAuthsession_AuthsessionSetAuthKey_Handler,
		},
		{
			MethodName: "authsession_bindAuthKeyUser",
			Handler:    _RPCAuthsession_AuthsessionBindAuthKeyUser_Handler,
		},
		{
			MethodName: "authsession_unbindAuthKeyUser",
			Handler:    _RPCAuthsession_AuthsessionUnbindAuthKeyUser_Handler,
		},
		{
			MethodName: "authsession_getPermAuthKeyId",
			Handler:    _RPCAuthsession_AuthsessionGetPermAuthKeyId_Handler,
		},
		{
			MethodName: "authsession_bindTempAuthKey",
			Handler:    _RPCAuthsession_AuthsessionBindTempAuthKey_Handler,
		},
		{
			MethodName: "authsession_setClientSessionInfo",
			Handler:    _RPCAuthsession_AuthsessionSetClientSessionInfo_Handler,
		},
		{
			MethodName: "authsession_getAuthorization",
			Handler:    _RPCAuthsession_AuthsessionGetAuthorization_Handler,
		},
		{
			MethodName: "authsession_getAuthStateData",
			Handler:    _RPCAuthsession_AuthsessionGetAuthStateData_Handler,
		},
		{
			MethodName: "authsession_setLayer",
			Handler:    _RPCAuthsession_AuthsessionSetLayer_Handler,
		},
		{
			MethodName: "authsession_setInitConnection",
			Handler:    _RPCAuthsession_AuthsessionSetInitConnection_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "authsession.tl.proto",
}

func (m *AuthKeyStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeyStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthKeyStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AndroidPushSessionId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AndroidPushSessionId))
		i--
		dAtA[i] = 0x40
	}
	if m.ClientType != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x38
	}
	if m.Layer != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x30
	}
	if m.KeyState != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.KeyState))
		i--
		dAtA[i] = 0x28
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthKeyStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthKeyStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthKeyStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.LangCode) > 0 {
		i -= len(m.LangCode)
		copy(dAtA[i:], m.LangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangCode)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.LangPack) > 0 {
		i -= len(m.LangPack)
		copy(dAtA[i:], m.LangPack)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangPack)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SystemLangCode) > 0 {
		i -= len(m.SystemLangCode)
		copy(dAtA[i:], m.SystemLangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemLangCode)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SystemVersion) > 0 {
		i -= len(m.SystemVersion)
		copy(dAtA[i:], m.SystemVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DeviceModel) > 0 {
		i -= len(m.DeviceModel)
		copy(dAtA[i:], m.DeviceModel)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.DeviceModel)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ApiId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ApiId))
		i--
		dAtA[i] = 0x30
	}
	if m.Layer != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLClientSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLClientSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLClientSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthorizations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthorizations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthorizations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExcludeAuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExcludeAuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionResetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionResetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionResetAuthorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hash != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLangPack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLangPack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLangPack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLangCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLangCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLangCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetUserId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetUserId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetUserId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetPushSessionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetPushSessionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetPushSessionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TokenType != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.TokenType))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetFutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetFutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetFutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionQueryAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionQueryAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionQueryAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpiresIn != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExpiresIn))
		i--
		dAtA[i] = 0x28
	}
	if m.FutureSalt != nil {
		{
			size, err := m.FutureSalt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKey != nil {
		{
			size, err := m.AuthKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionBindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionBindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionBindAuthKeyUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionUnbindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionUnbindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionUnbindAuthKeyUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetPermAuthKeyId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetPermAuthKeyId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetPermAuthKeyId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionBindTempAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionBindTempAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionBindTempAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EncryptedMessage) > 0 {
		i -= len(m.EncryptedMessage)
		copy(dAtA[i:], m.EncryptedMessage)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.EncryptedMessage)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Nonce != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.PermAuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.PermAuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetClientSessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetClientSessionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetClientSessionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Layer != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetInitConnection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetInitConnection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetInitConnection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.LangCode) > 0 {
		i -= len(m.LangCode)
		copy(dAtA[i:], m.LangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangCode)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.LangPack) > 0 {
		i -= len(m.LangPack)
		copy(dAtA[i:], m.LangPack)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangPack)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SystemLangCode) > 0 {
		i -= len(m.SystemLangCode)
		copy(dAtA[i:], m.SystemLangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemLangCode)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SystemVersion) > 0 {
		i -= len(m.SystemVersion)
		copy(dAtA[i:], m.SystemVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemVersion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DeviceModel) > 0 {
		i -= len(m.DeviceModel)
		copy(dAtA[i:], m.DeviceModel)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.DeviceModel)))
		i--
		dAtA[i] = 0x32
	}
	if m.ApiId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ApiId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_Long) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_Long) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_Long) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		dAtA7 := make([]byte, len(m.Datas)*10)
		var j6 int
		for _, num1 := range m.Datas {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuthsessionTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthsessionTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuthKeyStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.KeyState != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.KeyState))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Layer))
	}
	if m.ClientType != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ClientType))
	}
	if m.AndroidPushSessionId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AndroidPushSessionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthKeyStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClientSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Layer))
	}
	if m.ApiId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemLangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangPack)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLClientSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthorizations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.ExcludeAuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExcludeAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionResetAuthorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.Hash != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLangPack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLangCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetUserId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetPushSessionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.TokenType != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.TokenType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetFutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.Num != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionQueryAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKey != nil {
		l = m.AuthKey.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.FutureSalt != nil {
		l = m.FutureSalt.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExpiresIn))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionBindAuthKeyUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionUnbindAuthKeyUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetPermAuthKeyId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionBindTempAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.PermAuthKeyId))
	}
	if m.Nonce != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Nonce))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExpiresAt))
	}
	l = len(m.EncryptedMessage)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetClientSessionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Layer))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetInitConnection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.ApiId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemLangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangPack)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_Long) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		l = 0
		for _, e := range m.Datas {
			l += sovAuthsessionTl(uint64(e))
		}
		n += 1 + sovAuthsessionTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAuthsessionTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthsessionTl(x uint64) (n int) {
	return sovAuthsessionTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthKeyStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeyStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeyStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyState", wireType)
			}
			m.KeyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyState |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPushSessionId", wireType)
			}
			m.AndroidPushSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AndroidPushSessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthKeyStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authKeyStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authKeyStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AuthKeyStateData{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemLangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangPack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangPack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLClientSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_clientSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_clientSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &ClientSession{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthorizations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthorizations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthorizations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeAuthKeyId", wireType)
			}
			m.ExcludeAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionResetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_resetAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_resetAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLangPack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLangPack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLangPack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLangCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLangCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLangCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetUserId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getUserId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getUserId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetPushSessionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getPushSessionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getPushSessionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			m.TokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetFutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getFutureSalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getFutureSalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionQueryAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_queryAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_queryAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthKey == nil {
				m.AuthKey = &mtproto.AuthKeyInfo{}
			}
			if err := m.AuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureSalt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FutureSalt == nil {
				m.FutureSalt = &mtproto.FutureSalt{}
			}
			if err := m.FutureSalt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionBindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_bindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_bindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionUnbindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_unbindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_unbindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetPermAuthKeyId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getPermAuthKeyId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getPermAuthKeyId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionBindTempAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_bindTempAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_bindTempAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMessage = append(m.EncryptedMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedMessage == nil {
				m.EncryptedMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetClientSessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setClientSessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setClientSessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ClientSession{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetInitConnection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setInitConnection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setInitConnection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemLangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangPack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangPack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_Long) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_Long: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_Long: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Datas = append(m.Datas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuthsessionTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAuthsessionTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Datas) == 0 {
					m.Datas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthsessionTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Datas = append(m.Datas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthsessionTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthsessionTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuthsessionTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuthsessionTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuthsessionTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthsessionTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuthsessionTl = fmt.Errorf("proto: unexpected end of group")
)
